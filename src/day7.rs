//! --- Day 7: Laboratories ---
//!
//! You thank the cephalopods for the help and exit the trash compactor, finding yourself in the familiar halls of a North Pole research wing.
//!
//! Based on the large sign that says "teleporter hub", they seem to be researching teleportation; you can't help but try it for yourself and step onto the large yellow teleporter pad.
//!
//! Suddenly, you find yourself in an unfamiliar room! The room has no doors; the only way out is the teleporter. Unfortunately, the teleporter seems to be leaking magic smoke.
//!
//! Since this is a teleporter lab, there are lots of spare parts, manuals, and diagnostic equipment lying around. After connecting one of the diagnostic tools, it helpfully displays error code 0H-N0, which apparently means that there's an issue with one of the tachyon manifolds.
//!
//! You quickly locate a diagram of the tachyon manifold (your puzzle input). A tachyon beam enters the manifold at the location marked S; tachyon beams always move downward. Tachyon beams pass freely through empty space (.). However, if a tachyon beam encounters a splitter (^), the beam is stopped; instead, a new tachyon beam continues from the immediate left and from the immediate right of the splitter.
//!
//! For example:
//!
//! ```text
//! .......S.......
//! ...............
//! .......^.......
//! ...............
//! ......^.^......
//! ...............
//! .....^.^.^.....
//! ...............
//! ....^.^...^....
//! ...............
//! ...^.^...^.^...
//! ...............
//! ..^...^.....^..
//! ...............
//! .^.^.^.^.^...^.
//! ...............
//! ```
//! In this example, the incoming tachyon beam (|) extends downward from S until it reaches the first splitter:
//!
//! ```text
//! .......S.......
//! .......|.......
//! .......^.......
//! ...............
//! ......^.^......
//! ...............
//! .....^.^.^.....
//! ...............
//! ....^.^...^....
//! ...............
//! ...^.^...^.^...
//! ...............
//! ..^...^.....^..
//! ...............
//! .^.^.^.^.^...^.
//! ...............
//! ```
//! At that point, the original beam stops, and two new beams are emitted from the splitter:
//!
//! ```text
//! .......S.......
//! .......|.......
//! ......|^|......
//! ...............
//! ......^.^......
//! ...............
//! .....^.^.^.....
//! ...............
//! ....^.^...^....
//! ...............
//! ...^.^...^.^...
//! ...............
//! ..^...^.....^..
//! ...............
//! .^.^.^.^.^...^.
//! ...............
//! ```
//! Those beams continue downward until they reach more splitters:
//!
//! ```text
//! .......S.......
//! .......|.......
//! ......|^|......
//! ......|.|......
//! ......^.^......
//! ...............
//! .....^.^.^.....
//! ...............
//! ....^.^...^....
//! ...............
//! ...^.^...^.^...
//! ...............
//! ..^...^.....^..
//! ...............
//! .^.^.^.^.^...^.
//! ...............
//! ```
//! At this point, the two splitters create a total of only three tachyon beams, since they are both dumping tachyons into the same place between them:
//!
//! ```text
//! .......S.......
//! .......|.......
//! ......|^|......
//! ......|.|......
//! .....|^|^|.....
//! ...............
//! .....^.^.^.....
//! ...............
//! ....^.^...^....
//! ...............
//! ...^.^...^.^...
//! ...............
//! ..^...^.....^..
//! ...............
//! .^.^.^.^.^...^.
//! ...............
//! ```
//! This process continues until all of the tachyon beams reach a splitter or exit the manifold:
//!
//! ```text
//! .......S.......
//! .......|.......
//! ......|^|......
//! ......|.|......
//! .....|^|^|.....
//! .....|.|.|.....
//! ....|^|^|^|....
//! ....|.|.|.|....
//! ...|^|^|||^|...
//! ...|.|.|||.|...
//! ..|^|^|||^|^|..
//! ..|.|.|||.|.|..
//! .|^|||^||.||^|.
//! .|.|||.||.||.|.
//! |^|^|^|^|^|||^|
//! |.|.|.|.|.|||.|
//! ```
//! To repair the teleporter, you first need to understand the beam-splitting properties of the tachyon manifold. In this example, a tachyon beam is split a total of 21 times.
//!
//! Analyze your manifold diagram. How many times will the beam be split?

use std::collections::HashMap;

use crate::{
    Solution,
    direction::Direction,
    grid::{Coord, Grid},
};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum Cell {
    Empty,
    Start,
    Splitter,
    Laser,
}

impl std::fmt::Display for Cell {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Cell::Empty => write!(f, "."),
            Cell::Start => write!(f, "S"),
            Cell::Splitter => write!(f, "^"),
            Cell::Laser => write!(f, "|"),
        }
    }
}

pub struct Day7 {}

impl Solution for Day7 {
    fn new() -> Self {
        Self {}
    }

    fn part1(&mut self, input: &str) -> String {
        let mut grid = Grid::new(
            input,
            |c| match c {
                '.' => Cell::Empty,
                'S' => Cell::Start,
                '^' => Cell::Splitter,
                _ => panic!("Invalid character"),
            },
            false,
        );

        grid.set(
            grid.find(Cell::Start).unwrap() + Direction::Down,
            Cell::Laser,
        );

        loop {
            let cells_to_add_lasers = grid.find_where(|v, c| {
                *v != Cell::Laser
                    && ((*v == Cell::Empty && grid.get(c + Direction::Up) == Some(&Cell::Laser))
                        || ((grid.get(c + Direction::Left) == Some(&Cell::Splitter)
                            && grid.get(c + Direction::UpLeft) == Some(&Cell::Laser))
                            || (grid.get(c + Direction::Right) == Some(&Cell::Splitter)
                                && grid.get(c + Direction::UpRight) == Some(&Cell::Laser))))
            });

            if cells_to_add_lasers.is_empty() {
                break;
            }

            for c in cells_to_add_lasers {
                grid.set(c, Cell::Laser);
            }
        }

        grid.find_where(|v, c| {
            *v == Cell::Splitter && grid.get(c + Direction::Up) == Some(&Cell::Laser)
        })
        .len()
        .to_string()
    }

    fn part2(&mut self, input: &str) -> String {
        let grid = Grid::new(
            input,
            |c| match c {
                '.' => Cell::Empty,
                'S' => Cell::Start,
                '^' => Cell::Splitter,
                _ => panic!("Invalid character"),
            },
            false,
        );

        let mut splitter_cache: HashMap<Coord, u64> = HashMap::new();

        fn traverse_grid(
            grid: &Grid<Cell>,
            splitter_cache: &mut HashMap<Coord, u64>,
            coord: Coord,
        ) -> u64 {
            if !grid.is_coord_in_bounds(coord) {
                return 0;
            }
            if grid.get(coord) == Some(&Cell::Splitter) {
                if splitter_cache.contains_key(&coord) {
                    return splitter_cache[&coord];
                } else {
                    let ret = {
                        let left = traverse_grid(grid, splitter_cache, coord + Direction::Left);
                        let right = traverse_grid(grid, splitter_cache, coord + Direction::Right);
                        left + right
                    };
                    splitter_cache.insert(coord, ret);
                    return ret;
                }
            } else {
                let next_coord = coord + Direction::Down;
                if !grid.is_coord_in_bounds(next_coord) {
                    return 1;
                } else {
                    return traverse_grid(grid, splitter_cache, next_coord);
                }
            }
        }

        traverse_grid(
            &grid,
            &mut splitter_cache,
            grid.find(Cell::Start).unwrap() + Direction::Down,
        )
        .to_string()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_part1() {
        let mut solution = Day7::new();
        assert_eq!(
            solution.part1(
                r#".......S.......
...............
.......^.......
...............
......^.^......
...............
.....^.^.^.....
...............
....^.^...^....
...............
...^.^...^.^...
...............
..^...^.....^..
...............
.^.^.^.^.^...^.
..............."#
            ),
            String::from("21")
        );
    }

    #[test]
    fn test_part2() {
        let mut solution = Day7::new();
        assert_eq!(
            solution.part2(
                r#".......S.......
...............
.......^.......
...............
......^.^......
...............
.....^.^.^.....
...............
....^.^...^....
...............
...^.^...^.^...
...............
..^...^.....^..
...............
.^.^.^.^.^...^.
..............."#
            ),
            String::from("40")
        );
    }
}
